{
  "name": "css-layout",
  "version": "1.1.1",
  "description": "Reimplementation of CSS layout using pure JavaScript",
  "main": "dist/css-layout.js",
  "scripts": {
    "watch": "grunt watch",
    "test": "grunt ci"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/facebook/css-layout.git"
  },
  "keywords": [
    "css",
    "flexbox",
    "layout"
  ],
  "author": "",
  "license": "BSD",
  "bugs": {
    "url": "https://github.com/facebook/css-layout/issues"
  },
  "homepage": "https://github.com/facebook/css-layout",
  "devDependencies": {
    "babel-eslint": "^4.1.3",
    "fbjs-scripts": "^0.2.2",
    "grunt": "^0.4.5",
    "grunt-cli": "^0.1.13",
    "grunt-contrib-clean": "^0.6.0",
    "grunt-contrib-concat": "^0.5.1",
    "grunt-contrib-copy": "^0.8.0",
    "grunt-contrib-uglify": "^0.9.1",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-eslint": "^17.1.0",
    "grunt-execute": "^0.2.2",
    "grunt-include-replace": "^3.1.0",
    "grunt-karma": "^0.12.0",
    "grunt-mkdir": "^0.1.2",
    "grunt-shell": "^1.1.2",
    "jasmine-core": "^2.2.0",
    "karma": "^0.13.8",
    "karma-chrome-launcher": "^0.1.7",
    "karma-jasmine": "^0.3.5",
    "load-grunt-tasks": "^3.2.0"
  },
  "readme": "css-layout [![Build Status](https://travis-ci.org/facebook/css-layout.svg?branch=master)](https://travis-ci.org/facebook/css-layout)\n==========\n\nThis project implements a subset of CSS including flexbox and the box model using pure JavaScript, then transpiled to C and Java. The goal is to have a small standalone library to layout elements. It doesn't rely on the DOM at all.\n\nThe Java, C and JavaScript version of the code is available via [npm](https://www.npmjs.com/package/css-layout) or directly from the `dist` folder of this repo. The JavaScript version is also available via [cdnjs](https://cdnjs.com/libraries/css-layout).\n\nIn order to make sure that the code is correct, it is developed in JavaScript using TDD where each commit adds a unit test and the associated code to make it work. All the unit tests are tested against Chrome's implementation of CSS.\n\nThe JavaScript version has been implemented in a way that can be easily transpiled to C and Java via regexes. The layout function doesn't do any allocation nor uses any of the dynamic aspects of JavaScript. The tests are also transpiled to make sure that the implementations are correct everywhere.\n\n\nUsage\n-----\n\nA single function `computeLayout` is exposed that\n - takes a tree of nodes: `{ style: { ... }, children: [ nodes ] }`\n - computes the layout and writes it back to the node tree.\n\nFor example,\n\n```javascript\n// create an initial tree of nodes\nvar nodeTree = {\n    \"style\": {\n      \"padding\": 50\n    },\n    \"children\": [\n      {\n        \"style\": {\n          \"padding\": 10,\n          \"alignSelf\": \"stretch\"\n        }\n      }\n    ]\n  };\n\n// compute the layout\ncomputeLayout(nodeTree);\n\n// the layout information is written back to the node tree, with\n// each node now having a layout property: \n\n// JSON.stringify(nodeTree, null, 2);\n{\n  \"style\": {\n    \"padding\": 50\n  },\n  \"children\": [\n    {\n      \"style\": {\n        \"padding\": 10,\n        \"alignSelf\": \"stretch\"\n      },\n      \"layout\": {\n        \"width\": 20,\n        \"height\": 20,\n        \"top\": 50,\n        \"left\": 50,\n        \"right\": 50,\n        \"bottom\": 50,\n        \"direction\": \"ltr\"\n      },\n      \"children\": [],\n      \"lineIndex\": 0\n    }\n  ],\n  \"layout\": {\n    \"width\": 120,\n    \"height\": 120,\n    \"top\": 0,\n    \"left\": 0,\n    \"right\": 0,\n    \"bottom\": 0,\n    \"direction\": \"ltr\"\n  }\n}\n```\n\nSupported Attributes\n--------------------\n\nName | Value\n----:|------\nwidth, height | positive number\nminWidth, minHeight | positive number\nmaxWidth, maxHeight | positive number\nleft, right, top, bottom | number\nmargin, marginLeft, marginRight, marginTop, marginBottom | number\npadding, paddingLeft, paddingRight, paddingTop, paddingBottom | positive number\nborderWidth, borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth | positive number\nflexDirection | 'column', 'row'\njustifyContent | 'flex-start', 'center', 'flex-end', 'space-between', 'space-around'\nalignItems, alignSelf | 'flex-start', 'center', 'flex-end', 'stretch'\nflex | positive number\nflexWrap | 'wrap', 'nowrap'\nposition | 'relative', 'absolute'\n\n- `inherit` value is not implemented because it's a way to disambiguate between multiple colliding rules. This should be done in a pre-processing step, not in the actual layout algorithm.\n\n\n\nDefault values\n--------------\nSince we are only using flexbox, we can use defaults that are much more sensible. This is the configuration to use in order to get the same behavior using the DOM and CSS. You can try those default settings with the [following JSFiddle](http://jsfiddle.net/vjeux/y11txxv9/).\n\n```css\ndiv, span {\n  box-sizing: border-box;\n  position: relative;\n\n  display: flex;\n  flex-direction: column;\n  align-items: stretch;\n  flex-shrink: 0;\n  align-content: flex-start;\n\n  border: 0 solid black;\n  margin: 0;\n  padding: 0;\n}\n```\n\n- `box-sizing: border-box` is the most convenient way to express the relation between `width` and `borderWidth`.\n- Everything is `display: flex` by default. All the behaviors of `block` and `inline-block` can be expressed in term of `flex` but not the opposite.\n- All the flex elements are oriented from top to bottom, left to right and do not shrink. This is how things are laid out using the default CSS settings and what you'd expect.\n- Everything is `position: relative`. This makes `position: absolute` target the direct parent and not some parent which is either `relative` or `absolute`. If you want to position an element relative to something else, you should move it in the DOM instead of relying of CSS. It also makes `top, left, right, bottom` do something when not specifying `position: absolute`.\n\nNative Usage Notes\n------------------\n\nThe C equivalent of `computeLayout` is [`layoutNode`](dist/css-layout.h#L1378).\n\nIn order for layout to properly layout reflowable text, the `measure` function must be set on the `css_node` structure. The property can be found in [`css-layout.h`](dist/css-layout.h#L146). This function must take a void pointer to a `context` that will affect the size of the node and the `width` as computed by the layout engine, and must return a `css_dim_t` structure defining the actual needed size of the node. For the most part, the `context` field can be the text inside the node. No C implementation of this function is provided in provided - it depends on your use of css-layout. However an implementation of the function in JavaScript can be used for reference in the [test utilities](src/Layout-test-utils.js#L383).\n\nDevelopment\n-----------\n\nThe core logic resides with `Layout.js`, which is transpiled into equivalent C and Java implementations.\n\nThe JavaScript build process is managed via Grunt. The build performs linting, runs the tests against Chrome, transpiles and packages the code (JavaScript and Java) into the `dist` folder. For JavaScript, the build output uses the Universal Module Format (UMD) so that it can be used via AMD / RequireJS, CommonJS or included directly into an HTML page.\n\nWhile developing you can just run the lint / Chrome-based tests a follows:\n\n```\ngrunt test-javascript\n```\n",
  "readmeFilename": "README.md",
  "_id": "css-layout@1.1.1",
  "_shasum": "ada5bb8c901e475d41043a88e034ade54d939392",
  "_resolved": "https://registry.npmjs.org/css-layout/-/css-layout-1.1.1.tgz",
  "_from": "https://registry.npmjs.org/css-layout/-/css-layout-1.1.1.tgz"
}
